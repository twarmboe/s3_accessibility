#pragma METAINFO("gyrotest", 1, 0, "beerSnobbery")

#include "safeprint.gph"
#include "rstick.gph"
#include "flickstick.gph"
#include "settings.gph"
#include "io_sync.gph"
#include <switch.gph>
#include "vector_rotation.gph"

fix32 lastAngle = 0.0;
fix32 lastMagnitude = 0.0;

fix32 normalizedAcc[3] = {0.0, 0.0, 0.0};

fix32 lastActiveAcc[3] = {0.0, 0.0, -25.0};
fix32 accRotation[4] = {1.0, 0.0, 0.0, 0.0}; // start with identity q

init {
	initConstants();
	
	if(booyahSwap){
		remapper_swap( SWITCH_L , SWITCH_DOWN );
	}
	
	if(rumbleOff){
		ffb_set(FFB_1, 0.0, 100);
		ffb_set(FFB_2, 0.0, 100);
		ffb_set(FFB_3, 0.0, 100);
		ffb_set(FFB_4, 0.0, 100);
	}
	
}

// these reset every time we output data to console
fix32 gyroAccumulatorX = 0.0;
fix32 gyroAccumulatorY = 0.0;
fix32 gyroAccumulatorZ = 0.0;
fix32 flickYawAccumulator = 0.0;

bool blockGyro = FALSE;

main
{
	
	
	//set_val(SWITCH_ZR, 100.0);
	
	//update values used for synchronization
	updateIO();
	
	if(flickStickEnabled){
		blockRightStick();
	}
	
	if(get_val(SWITCH_ZR) > zrThresholdPercentage){
		set_val(SWITCH_ZR, 100.0);
	} else {
		set_val(SWITCH_ZR, 0.0);
	}
	
	if(outputWasProcessed){
		//reset our accumulators
		gyroAccumulatorX = 0.0;
		gyroAccumulatorY = 0.0;
		gyroAccumulatorZ = 0.0;
		flickYawAccumulator = 0.0;		
	}
	
	if(booyahTurbo){
		if(is_active(SWITCH_DOWN)) combo_run(turboBooyah);
		if(event_release(SWITCH_DOWN)) combo_stop(turboBooyah);
	}
	
	
	if(superJumpOnLs && event_active(SWITCH_LS)) combo_run(JumpToBase);
	
	fix32 accX = get_val(ACCEL_1_X);
	fix32 accY = get_val(ACCEL_1_Y);
	fix32 accZ = get_val(ACCEL_1_Z);
	fix32 accMag = sqrt(sq(accX) + sq(accY) + sq(accZ));
	
	normalizedAcc[0] = -accX/accMag;
	normalizedAcc[1] = -accY/accMag;
	normalizedAcc[2] = -accZ/accMag;
	
	
	if(event_active(SWITCH_Y)){
		
		blockGyro = TRUE;
		
		lastActiveAcc[0] = normalizedAcc[0];
		lastActiveAcc[1] = normalizedAcc[1];
		lastActiveAcc[2] = normalizedAcc[2];
		
	} else if(event_release(SWITCH_Y)) {
		
		blockGyro = FALSE;
		
		fix32 r[4] = {1.0, 0.0, 0.0, 0.0};
		Quaternion_rotationBetween(ARG(normalizedAcc), ARG(lastActiveAcc), ARG(r));
		Quaternion_multiply(ARG(accRotation), ARG(r), ARG(accRotation));
	}
	
	if(is_active(SWITCH_Y)){
		set_val(SWITCH_Y, 0.0);	
	}
	
	
	uint32 dt = elapsed_time();
	
	//can only update flickstick values if measurable time has elapsed
	if(flickStickEnabled && dt > 0) {
		fix32 rsAngle = rightStickAngle();
		fix32 magnitude = rightStickMagnitude();
		
		fix32 flickAmount = handleFlickStick(lastAngle, lastMagnitude, rsAngle, magnitude, dt);
		
		lastAngle = rsAngle;
		lastMagnitude = magnitude;
	
		flickYawAccumulator += (flickAmount * flickMult);	  
	}
	
	//add any new inputs to be averaged until next output
	if(inputIsNew){
		gyroAccumulatorX += get_actual(GYRO_1_X) * gyroMult;
		gyroAccumulatorY += get_actual(GYRO_1_Y) * gyroMult;
		gyroAccumulatorZ += get_actual(GYRO_1_Z) * gyroMult;
	}
	
	if(blockGyro){
		normalizedAcc[0] = lastActiveAcc[0];
		normalizedAcc[1] = lastActiveAcc[1];
		normalizedAcc[2] = lastActiveAcc[2];
	}
	
	//rotate
	Quaternion_rotate(ARG(accRotation), ARG(normalizedAcc), ARG(normalizedAcc));
	
	set_val(SWITCH_ACCX, normalizedAcc[0] * -25.0);
	set_val(SWITCH_ACCY, normalizedAcc[1] * -25.0);
	set_val(SWITCH_ACCZ, normalizedAcc[2] * -25.0);

	
	//average our gyro data and apply our flick based on the normalized accelerometer
	fix32 avgX = get_actual(SWITCH_GYROX) * gyroMult;
	if(inputsSinceLast > 0){
		avgX = gyroAccumulatorX / (fix32) inputsSinceLast;
	}
	if(blockGyro){ 
		avgX = 0.0; 
	}
	
	fix32 newX = avgX + (flickYawAccumulator * normalizedAcc[0]);
	set_val(SWITCH_GYROX, newX);
	
	fix32 avgY = get_actual(SWITCH_GYROY) * gyroMult;
	
	if(inputsSinceLast > 0){
		avgY = gyroAccumulatorY / (fix32) inputsSinceLast;
	}
	if(blockGyro){ 
		avgY = 0.0; 
	}
	
	
	fix32 newY = avgY + (flickYawAccumulator * normalizedAcc[1]);
	set_val(SWITCH_GYROY, newY);
	
	fix32 avgZ = get_actual(SWITCH_GYROZ) * gyroMult;
	if(inputsSinceLast > 0){
		avgZ = gyroAccumulatorZ / (fix32) inputsSinceLast;
	}
	if(blockGyro){ 
		avgZ = 0.0; 
	}
	
	
	fix32 newZ = avgZ + (flickYawAccumulator * normalizedAcc[2]);
	set_val(SWITCH_GYROZ, newZ);
	
	
	//dumb 360 lol
	//if(event_active(BUTTON_15)){
	//	combo_run(Spin);
	//}
	
	//dumb bamboo 360 lol
	//if(event_release(BUTTON_5)){
	//	combo_run(ShootSpin);
	//}
}

combo turboBooyah
{
	set_val(SWITCH_DOWN, 100);
	wait(40);
	set_val(SWITCH_DOWN, 0);
	wait(40);
}

combo JumpToBase
{
	set_val(SWITCH_X, 100);
	wait(50);
	set_val(SWITCH_DOWN, 100);
	wait(50);
	set_val(SWITCH_A, 100);
	wait(50);
	set_val(SWITCH_X, 0);
	set_val(SWITCH_DOWN, 0);
	set_val(SWITCH_A, 0);
}

//do a 360 @ +5 sens
combo Spin 
{
	set_val(GYRO_1_X, normalizedAcc[0] * 60.0);
	set_val(GYRO_1_Y, normalizedAcc[1] * 60.0);
	set_val(GYRO_1_Z, normalizedAcc[2] * 60.0);
	wait(200);
}


combo ShootSpin 
{
	wait(20);
	set_val(GYRO_1_X, normalizedAcc[0] * 60.0);
	set_val(GYRO_1_Y, normalizedAcc[1] * 60.0);
	set_val(GYRO_1_Z, normalizedAcc[2] * 60.0);
	wait(100);
	set_val(SWITCH_ZR, 100.0);
	set_val(GYRO_1_X, normalizedAcc[0] * 60.0);
	set_val(GYRO_1_Y, normalizedAcc[1] * 60.0);
	set_val(GYRO_1_Z, normalizedAcc[2] * 60.0);
	wait(100);
	set_val(SWITCH_ZR, 100.0);
	wait(50);
	set_val(SWITCH_ZR, 0);
	wait(20);
}